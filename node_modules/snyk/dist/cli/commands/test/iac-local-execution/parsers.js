"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseIacFile = void 0;
const hclToJson = require("hcl-to-json");
const YAML = require("js-yaml");
const types_1 = require("./types");
const REQUIRED_K8S_FIELDS = ['apiVersion', 'kind', 'metadata'];
function tryParseIacFile(fileMetadata, fileContent) {
    switch (fileMetadata.fileType) {
        case 'yaml':
        case 'yml':
        case 'json':
            return tryParsingKubernetesFile(fileContent, fileMetadata);
        case 'tf':
            return [tryParsingTerraformFile(fileContent, fileMetadata)];
        default:
            throw new Error('Invalid IaC file');
    }
}
exports.tryParseIacFile = tryParseIacFile;
function tryParsingKubernetesFile(fileContent, fileMetadata) {
    const yamlDocuments = YAML.safeLoadAll(fileContent);
    return yamlDocuments.map((parsedYamlDocument, docId) => {
        if (REQUIRED_K8S_FIELDS.every((requiredField) => parsedYamlDocument.hasOwnProperty(requiredField))) {
            return Object.assign(Object.assign({}, fileMetadata), { fileContent: fileContent, jsonContent: parsedYamlDocument, engineType: types_1.EngineType.Kubernetes, docId });
        }
        else {
            throw new Error('Invalid K8s File!');
        }
    });
}
function tryParsingTerraformFile(fileContent, fileMetadata) {
    try {
        // TODO: This parser does not fail on inavlid Terraform files! it is here temporarily.
        // cloud-config team will replace it to a valid parser for the beta release.
        const parsedData = hclToJson(fileContent);
        return Object.assign(Object.assign({}, fileMetadata), { fileContent: fileContent, jsonContent: parsedData, engineType: types_1.EngineType.Terraform });
    }
    catch (err) {
        throw new Error('Invalid Terraform File!');
    }
}
//# sourceMappingURL=parsers.js.map